from typing import List, Optional

from sqlalchemy import BigInteger, Boolean, Float, ForeignKey, Integer, Text
from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship

__all__ = ("Guild", "Role", "Member", "Time", "async_session", "create_db")


class Base(DeclarativeBase):
    ...


class Role(Base):
    """
    Represents the role table within the database. This table is responsible for storing all role IDs
    the guild has configured for mod_role or roles allowed to use the punch buttons

    id: :type:`BigInteger`
        Role's Discord ID
    guild_id: :type:`BigInteger`
        Guild's Discord ID - related to the guild.id mapped_column in guild table
    is_mod: :type:`Boolean`
        True if this role is a mod role
    can_punch: :type:`Boolean`
        True if this role is allowed to punch
    """

    __tablename__ = "role"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    guild_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("guild.id"))
    is_mod: Mapped[bool] = mapped_column(Boolean, nullable=False)
    can_punch: Mapped[bool] = mapped_column(Boolean, nullable=False)


class Time(Base):
    """
    Represents the time table within the database. This table is responsible for storing
    member punch in and out times

    Attributes
    id: :type:`Integer`
        Row ID generated by the database
    punch_in: :type:`TIMESTAMP`
        The unix timestamp (as UTC) for when the member punched in
    punch_out: :type:`TIMESTAMP`
        The unix timestamp (as UTC) for when the member punched out
    """

    __tablename__ = "time"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    member_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("member.id"))
    punch_in: Mapped[float] = mapped_column(Float, nullable=False)
    punch_out: Mapped[Optional[float]] = mapped_column(Float, nullable=True, default=None)


class Member(Base):
    """
    Represents the member table from the database. This table stores members and has a relationship
    for the member to it's times within the time table

    Attributes
    ----------
    id: :type:`BigInteger`
        Member's Discord ID
    guild_id: :type:`BigInteger`
        Guild's Discord ID - related to the guild.id mapped_column in the guild table
    on_duty: :type:`Boolean`
        True if the member is on duty, else False
    times: :type:`relationship('Time')`
        Relationship to the Time table that stores the member punch in and out times
    """

    __tablename__ = "member"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    guild_id: Mapped[int] = mapped_column(BigInteger, ForeignKey("guild.id"))
    on_duty: Mapped[bool] = mapped_column(Boolean, nullable=False)
    times: Mapped[List[Time]] = relationship("Time")

    __mapper_args__ = {"eager_defaults": True}


class Guild(Base):
    """
    Represents the guild table from the database. This table stores config
    information about the guild

    Attributes
    ----------
    id: :type:`BigInteger`
        Guild's Discord ID
    message_id: :type:`BigInteger`
        Discord ID for the message where the embed is located
    embed: :type:`Text`
        The serialized embed the guild is using for their Punch In/Out message
    members: :type:`relationship('Member')`
        List of members associated with this guild
    roles :type:`relationship('Role')`
        The relationship to the Role table that stores guild roles allowed to use punch button and mod roles
    """

    __tablename__ = "guild"

    id: Mapped[int] = mapped_column(BigInteger, primary_key=True)
    message_id: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)
    channel_id: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)
    embed: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    members: Mapped[List[Member]] = relationship("Member")
    roles: Mapped[List[Role]] = relationship("Role")

    __mapper_args__ = {"eager_defaults": True}


engine: AsyncEngine = create_async_engine(
    "sqlite+aiosqlite:///timeclock/database/data.sqlite3", echo=False
)
async_session: async_sessionmaker[AsyncSession] = async_sessionmaker(
    engine, expire_on_commit=False, class_=AsyncSession
)


async def create_db(engine=engine, Base=Base):
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)
    await engine.dispose()


if __name__ == "__main__":
    import asyncio

    engine = create_async_engine("sqlite+aiosqlite:///database/data.sqlite3", echo=True)
    asyncio.run(create_db(engine, Base))
